<!--
  - @copyright Copyright (c) 2018 John Molakvoæ <skjnldsv@protonmail.com>
  -
  - @author John Molakvoæ <skjnldsv@protonmail.com>
  -
  - @license GNU AGPL version 3 or any later version
  -
  - This program is free software: you can redistribute it and/or modify
  - it under the terms of the GNU Affero General Public License as
  - published by the Free Software Foundation, either version 3 of the
  - License, or (at your option) any later version.
  -
  - This program is distributed in the hope that it will be useful,
  - but WITHOUT ANY WARRANTY; without even the implied warranty of
  - MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  - GNU Affero General Public License for more details.
  -
  - You should have received a copy of the GNU Affero General Public License
  - along with this program. If not, see <http://www.gnu.org/licenses/>.
  -
  -->

<template>
	<AppContentList>
		<div class="contacts-list__header">
			<Actions
				class="merge-button"
				menu-align="right">
				<slot>
					<ActionButton icon="icon-qrcode" @click="autoMergeContact">
						{{ t('contacts', 'Auto Merge') }}
					</ActionButton>
				</slot>
				<slot v-if="selected.length >= 2">
					<ActionButton icon="icon-clone" @click="mergeContact">
						{{ t('contacts', 'Merge') }}
					</ActionButton>
				</slot>
				<slot v-if="selected.length >= 1">
					<ActionButton icon="icon-delete" @click="deleteMultipleContact">
						{{ t('contacts', 'Delete') }}
					</ActionButton>
				</slot>
			</Actions>
		</div>
		<VirtualList ref="scroller"
			class="contacts-list"
			data-key="key"
			:data-sources="filteredList"
			:data-component="ContactsListItem"
			:estimate-size="68"
			:extra-props={selected}
			@update-check-selected="selectionChanged" />
	</AppContentList>
</template>

<script>
import AppContentList from '@nextcloud/vue/dist/Components/AppContentList'
import ContactsListItem from './ContactsList/ContactsListItem'
import VirtualList from 'vue-virtual-scroll-list'
import Actions from '@nextcloud/vue/dist/Components/Actions'
import ActionButton from '@nextcloud/vue/dist/Components/ActionButton'

export default {
	name: 'ContactsList',

	components: {
		AppContentList,
		VirtualList,
		Actions,
		ActionButton,
	},

	props: {
		list: {
			type: Array,
			required: true,
		},
		contacts: {
			type: Object,
			required: true,
		},
		searchQuery: {
			type: String,
			default: '',
		},
	},

	data() {
		return {
			ContactsListItem,
			selected: [],
		}
	},

	computed: {
		selectedContact() {
			return this.$route.params.selectedContact
		},
		selectedGroup() {
			return this.$route.params.selectedGroup
		},
		filteredList() {
			return this.list
				.filter(item => this.matchSearch(this.contacts[item.key]))
				.map(item => this.contacts[item.key])
		},
	},

	watch: {
		selectedContact(key) {
			this.$nextTick(() => {
				this.scrollToContact(key)
			})
		},
		list(val, old) {
			// we just loaded the list and the url already have a selected contact
			// if not, the selectedContact watcher will take over
			// to select the first entry
			if (val.length !== 0 && old.length === 0 && this.selectedContact) {
				this.$nextTick(() => {
					this.scrollToContact(this.selectedContact)
				})
			}
		},
	},

	methods: {
		// Select closest contact on deletion
		selectContact(oldIndex) {
			if (this.list.length > 0 && oldIndex < this.list.length) {
				// priority to the one above then the one after
				const newContact = oldIndex === 0 ? this.list[oldIndex + 1] : this.list[oldIndex - 1]
				if (newContact) {
					this.$router.push({ name: 'contact', params: { selectedGroup: this.selectedGroup, selectedContact: newContact.key } })
				}
			}
		},

		/**
		 * Scroll to the desired contact if in the list and not visible
		 *
		 * @param {string} key the contact unique key
		 */
		scrollToContact(key) {
			const item = this.$el.querySelector('#' + btoa(key).slice(0, -2))

			// if the item is not visible in the list or barely visible
			if (!(item && item.getBoundingClientRect().y > 50)) { // header height
				const index = this.list.findIndex(contact => contact.key === key)
				if (index > -1) {
					this.$refs.scroller.scrollToIndex(index)
				}
			}

			// if item is a bit out (bottom) of the list, let's just scroll a bit to the top
			if (item) {
				const pos = item.getBoundingClientRect().y + this.itemHeight - (this.$el.offsetHeight + 50)
				if (pos > 0) {
					const scroller = this.$refs.scroller.$el
					scroller.scrollToOffset(scroller.scrollTop + pos)
				}
			}
		},

		/**
		 * Is this matching the current search ?
		 *
		 * @param {Contact} contact the contact to search
		 * @return {boolean}
		 */
		matchSearch(contact) {
			if (this.searchQuery.trim() !== '') {
				return contact.searchData.toString().toLowerCase().search(this.searchQuery.trim().toLowerCase()) !== -1
			}
			return true
		},
		selectionChanged(newValue) {
			if (this.selected.includes(newValue)) {
				this.selected.splice(this.selected.indexOf(newValue), 1)
			} else {
				this.selected.push(newValue)
			}
		},
		deleteMultipleContact() {
			const temp = []
			this.selected.forEach(element => {
				if (this.contacts[element]) {
					// delete contact
					this.$store.dispatch('deleteContact', { contact: this.contacts[element] })
					temp.push(this.selected.indexOf(element), 1)
				}
			})
			// delete the uid in selected of the contact deleted
			temp.forEach(el => {
				this.selected.splice(temp, 1)
			})
		},
		cleanContactValue(contact, value) {
			contact.jCal[1].forEach(element => {
				if (element[0] === value[0] && element[3] === '' && !Array.isArray(element[3])) {
					contact.jCal[1].splice(contact.jCal[1].indexOf(element), 1)
				} else if (element[0] === value[0] && Array.isArray(element[3])) {
					let isempty = true
					element[3].forEach(arr => {
						if (arr !== '') {
							isempty = false
						}
					})
					if (isempty === true) {
						contact.jCal[1].splice(contact.jCal[1].indexOf(element), 1)
					}
				}
			})
		},
		addValue(firstContact, jcalvalue) {
			jcalvalue.filter(element => {
				// exclude the unique field we don't want to add
				return !['uid', 'version', 'fn', 'prodid', 'gender', 'rev'].includes(element[0])
			}).forEach(value => {
				if (value[0] === 'categories') {
					value.slice(3).forEach(element => {
						const data = firstContact.groups
						if (!firstContact.groups.includes(element)) {
							data.push(element)
							this.$store.dispatch('addContactToGroup', {
								contact: firstContact,
								groupName: element,
							})
							firstContact.groups = data
						}
					})
				} else if (Array.isArray(value[3])) {
					let isempty = true
					value[3].forEach(arr => {
						if (arr !== '') {
							isempty = false
						}
					})
					if (isempty === false) {
						// delete blank field of the same type and push the new field
						this.cleanContactValue(firstContact, value)
						firstContact.jCal[1].push(value)
					}
				} else if (value[3] !== '') {
					let include = false
					firstContact.jCal[1].forEach(element => {
						if (element[0] === value[0] && element[3] === value[3]) {
							include = true
						}
					})
					if (!include) {
						// delete blank field of the same type and push the new field
						this.cleanContactValue(firstContact, value)
						firstContact.jCal[1].push(value)
					}
				}
			})
			return firstContact
		},
		mergeContact() {
			const firstContact = this.contacts[this.selected[0]]
			this.selected.slice(1).forEach((element) => {
				if (this.contacts[element]) {
					const contactjcal = this.contacts[element].jCal[1]
					this.addValue(firstContact, contactjcal)
					// delete the contact merged and the uid in the selected
					this.$store.dispatch('deleteContact', { contact: this.contacts[element] })
				}
			})
			this.$store.dispatch('updateContact', firstContact)
			this.selected = []
		},
		getKey(contact, index) {
			if (!this.selected.includes(contact[index].key)) {
				this.selected.push(contact[index].key)
			}
		},
		verifyContact(contactOne, contactTwo) {
			let isOk = false
			contactOne.forEach(element => {
				contactTwo.forEach(el => {
					if (el[3] === element[3] && el[3] !== '' && element[3] !== '') {
						isOk = true
					}
				})
			})
			return isOk
		},
		deleteTempContact(contact) {
			contact.forEach(element => {
				this.selected.forEach(el => {
					if (element.key === el) {
						contact.splice(contact.indexOf(element), 1)
					}
				})
			})
			return contact
		},
		autoMergeContact() {
			const contact = this.list.filter(item => this.matchSearch(this.contacts[item.key]))
			for (let i = 0; i < contact.length; i++) {
				const val = contact.map(item => this.contacts[item.key].jCal[1].filter(el => { return !['uid', 'version', 'prodid', 'rev', 'adr'].includes(el[0]) }))
				this.getKey(contact, i)
				for (let n = 0; n < val.length; n++) {
					if (n !== i) {
						if (this.verifyContact(val[i], val[n])) {
							this.getKey(contact, n)
						}
					}
				}
				this.deleteTempContact(contact)
				if (this.selected.length > 1) {
					this.mergeContact()
				}
				this.selected = []
			}
		},
	},
}
</script>

<style lang="scss" scoped>
// Make virtual scroller scrollable
.contacts-list {
	max-height: calc(100vh - var(--header-height) - 48px);
	overflow: auto;
}

// Add empty header to contacts-list that solves overlapping of contacts with app-navigation-toogle
.contacts-list__header {
	min-height: 48px;
}

.merge-button {
	float: right;
}
</style>
